import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { getElementSize } from '@consta/uikit/useResizeObserved';
import { useEffect } from 'react';
export var defaultItemsCalculationCount = 1;
export var arraysIsEq = function arraysIsEq(arr1, arr2) {
  return arr1.join('-') === arr2.join('-');
};
export var useScroll = function useScroll(ref, fn, isActive) {
  useEffect(function () {
    if (isActive) {
      var _ref$current;

      (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.addEventListener('scroll', fn);
    }

    return function () {
      var _ref$current2;

      (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.removeEventListener('scroll', fn);
    };
  }, [ref.current, fn, isActive]);
};
export var getElementHeight = function getElementHeight(el) {
  return getElementSize(el).height;
};

var roundPositionByGap = function roundPositionByGap(position, gap) {
  if (position <= 0) {
    return 0;
  }

  return Math.ceil(position / gap) * gap;
};

export var getVisiblePosition = function getVisiblePosition(top, height, elementMaxSize) {
  var gap = height > elementMaxSize * defaultItemsCalculationCount ? height : elementMaxSize * defaultItemsCalculationCount;
  var visiblePosition = [Math.ceil(roundPositionByGap(height < gap ? top - (gap + height) : top - (gap + height / 2), height)), Math.ceil(roundPositionByGap(top === 0 ? gap : top + gap * 1.25, height))];
  return visiblePosition;
};
export var calculateSavedSizes = function calculateSavedSizes(savedSizes, sizes) {
  var newSavedSizes = _toConsumableArray(savedSizes);

  for (var _index = 0; _index < sizes.length; _index++) {
    var element = sizes[_index];

    if (element > 0) {
      newSavedSizes[_index] = element;
    }
  }

  return newSavedSizes;
};

var addCount = function addCount(pxs, visiblePosition, savedSize) {
  var lastSavedSize = savedSize.slice(-50);
  var average = lastSavedSize.reduce(function (a, b) {
    return a + b;
  }, 0) / lastSavedSize.length;
  var add = 0;

  if (visiblePosition[1] < pxs[1] + add * average) {
    return add;
  }

  while (visiblePosition[1] > pxs[1] + add * average) {
    add += defaultItemsCalculationCount;
  }

  return add;
};

export var calculateBounds = function calculateBounds(savedSizes, sizes, visiblePosition, length) {
  var pxs = [0, 0];
  var indexs = [0, 0];

  for (var _index2 = 0; _index2 < savedSizes.length; _index2++) {
    if (visiblePosition[0] > pxs[0]) {
      pxs[0] += savedSizes[_index2];
      indexs[0] = _index2 + 1;
    }

    if (visiblePosition[1] > pxs[1]) {
      pxs[1] += savedSizes[_index2];
      indexs[1] = _index2 + 1;
    }
  }

  if (indexs[0] === 0 && indexs[1] === 0) {
    indexs[1] = defaultItemsCalculationCount;
  }

  if (sizes.length !== savedSizes.length) {
    indexs[1] += addCount(pxs, visiblePosition, savedSizes);
  }

  if (indexs[1] > length) {
    indexs[1] = length;
  }

  return [pxs, indexs];
};
//# sourceMappingURL=helpers.js.map