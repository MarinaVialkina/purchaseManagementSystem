import { objectWithDefault } from '@consta/uikit/__internal__/src/utils/object/objectWithDefault';
import { useCreateAtom } from '@consta/uikit/__internal__/src/utils/state/useCreateAtom';
import { usePropAtom } from '@consta/uikit/__internal__/src/utils/state/usePickAtom';
import { useSendToAtom } from '@consta/uikit/__internal__/src/utils/state/useSendToAtom';
import { useAction, useAtom, useUpdate } from '@reatom/npm-react';
import { createRef, useMemo, useRef } from 'react';
import { useResizeObservedAtom } from "../useResizeObservedAtom";
import { arraysIsEq, calculateBounds, calculateSavedSizes, defaultItemsCalculationCount, getElementHeight, getVisiblePosition, useScroll } from "./helpers";
var visiblePositionInitial = [0, 0];
export var useVirtualScrollAtom = function useVirtualScrollAtom(props) {
  var propsWithDefault = objectWithDefault({
    isActive: false
  }, props);
  var propsAtom = useSendToAtom(propsWithDefault);
  var lengthAtom = usePropAtom(propsAtom, 'length');
  var isActiveAtom = usePropAtom(propsAtom, 'isActive');
  var onScrollToBottomAtom = usePropAtom(propsAtom, 'onScrollToBottom');
  var visiblePositionAtom = useCreateAtom(visiblePositionInitial);
  var boundsAtom = useCreateAtom([[0, 0], [0, propsWithDefault.isActive ? defaultItemsCalculationCount : propsWithDefault.length]]);
  var setBoundsAction = useAction(function (ctx, value) {
    var currentValue = ctx.get(boundsAtom);

    if (!arraysIsEq(currentValue[0], value[0]) || !arraysIsEq(currentValue[1], value[1])) {
      boundsAtom(ctx, value);
    }
  });
  var sliceStartAtom = useCreateAtom(function (ctx) {
    return ctx.spy(boundsAtom)[1][0];
  });
  var sliceEndAtom = useCreateAtom(function (ctx) {
    var sliceEnd = ctx.spy(boundsAtom)[1][1];
    return sliceEnd < 50 ? 50 : sliceEnd;
  });
  var sliceAtom = useCreateAtom(function (ctx) {
    return [ctx.spy(sliceStartAtom), ctx.spy(sliceEndAtom)];
  });
  var spaceTopAtom = useCreateAtom(function (ctx) {
    return ctx.spy(boundsAtom)[0][0];
  });
  var listRefsAtom = useCreateAtom(function (ctx) {
    var length = ctx.spy(lengthAtom);
    ctx.spy(visiblePositionAtom);
    return new Array(length).fill(null).map(createRef);
  });
  var scrollElementRef = useRef(null);
  var sizesAtom = useResizeObservedAtom(useAtom(listRefsAtom)[0], getElementHeight);
  var savedSizesAtom = useCreateAtom([]);
  var scrollElementRefHeightArrayAtom = useResizeObservedAtom(useMemo(function () {
    return [scrollElementRef];
  }, [scrollElementRef]), getElementHeight);
  var scrollElementRefHeightAtom = useCreateAtom(function (ctx) {
    return ctx.spy(scrollElementRefHeightArrayAtom)[0];
  });
  var calculateVisiblePosition = useAction(function (ctx) {
    var scrollElement = scrollElementRef.current;

    if (!scrollElement) {
      return;
    }

    var elementMaxSize = Math.max.apply(null, ctx.get(sizesAtom));
    var visiblePosition = getVisiblePosition(scrollElement.scrollTop, getElementHeight(scrollElement), elementMaxSize);
    var state = ctx.get(visiblePositionAtom);

    if (visiblePosition[0] !== state[0] || visiblePosition[1] !== state[1]) {
      visiblePositionAtom(ctx, visiblePosition);
    }
  });
  useScroll(scrollElementRef, calculateVisiblePosition, propsWithDefault.isActive);
  useUpdate(calculateVisiblePosition, [scrollElementRefHeightAtom, isActiveAtom]);
  useUpdate(function (ctx, visiblePosition, sizes, length, isActive) {
    if (isActive) {
      var savedSizes = ctx.get(savedSizesAtom);
      var newSavedSizes = calculateSavedSizes(savedSizes, sizes);
      savedSizesAtom(ctx, newSavedSizes);
      setBoundsAction(calculateBounds(newSavedSizes, sizes, visiblePosition, length));
    } else {
      var state = ctx.get(boundsAtom);

      if (state[0][0] !== 0 || state[0][1] !== 0 || state[1][0] !== 0 || state[1][1] !== length) {
        setBoundsAction([[0, 0], [0, length]]);
      }
    }
  }, [visiblePositionAtom, sizesAtom, lengthAtom, isActiveAtom]);
  useUpdate(function (ctx, slice) {
    var length = ctx.get(lengthAtom);
    var onScrollToBottom = ctx.get(onScrollToBottomAtom);

    if (onScrollToBottom && slice >= length) {
      onScrollToBottom(length);
    }
  }, [sliceEndAtom]);
  useUpdate(function (ctx, isActive) {
    var length = ctx.get(lengthAtom);
    var bounds = ctx.get(boundsAtom);
    var visiblePosition = ctx.get(visiblePositionAtom);
    var resetVisiblePosition = [0, 0];
    var resetBounds = [[0, 0], [0, isActive ? defaultItemsCalculationCount : length]];

    if (!(arraysIsEq(bounds[0], resetBounds[0]) && arraysIsEq(bounds[1], resetBounds[1]))) {
      boundsAtom(ctx, resetBounds);
    }

    if (!arraysIsEq(visiblePosition, resetVisiblePosition)) {
      visiblePositionAtom(ctx, resetVisiblePosition);
    }
  }, [isActiveAtom]);
  return {
    listRefsAtom: listRefsAtom,
    scrollElementRef: scrollElementRef,
    sliceAtom: sliceAtom,
    spaceTopAtom: spaceTopAtom
  };
};
//# sourceMappingURL=useVirtualScrollAtom.js.map