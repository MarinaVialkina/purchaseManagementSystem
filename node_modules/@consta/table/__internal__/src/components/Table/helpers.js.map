{"version":3,"file":"helpers.js","names":["useCreateAtom","getElementSize","useAtom","createRef","useResizeObservedAtom","get","set","columnDefaultMinWidth","separatorWidth","separatorLargeWidth","reduceSum","previousValue","currentValue","getLastChildrenCount","columns","count","traverse","cols","forEach","item","length","mapColumns","fn","stopRef","current","index","currentIndex","nextIndex","slice","Number","d","upIndex","pushByKey","pushed","inColumns","needAdd","key","keySplited","split","parentKey","join","push","pushIndex","pushByIndex","pinned","i","currentI","tree","filter","el","transformPinnedColumns","pinnedLeftColumns","pinnedRightColumns","otherColumns","notPinnedColumns","isSeparator","accessor","transformColumns","maxLevel","stack","headersArr","col","level","node","topHeaderGridIndex","prevItem","gridIndex","position","colSpan","mainId","colId","handledItem","rowSpan","map","parentId","pop","getMaxLevel","getIsFirst","column","parent","find","getLowHeaders","lowHeaders","getStickyTopOffsets","flattenedHeaders","headerRowsHeights","stickyTopOffsets","reduce","getResizerTopOffsets","resizerTopOffsets","topOffsetIndex","findIndex","getFlattenedHeadersLowCellsKeys","lowCells","flattenedHeaderCell","keys","getHeaderStickyLeftOffsets","lowCellsKeys","Math","min","getHeaderStickyRightOffsets","max","useHeaderData","columnsAtom","virtualScrollAtom","horizontalVirtualScrollAtom","ctx","virtualScroll","spy","Array","isArray","columnsWithPinnedAtom","headersAtom","columnsWithPinned","flattenedHeadersAtom","headers","flat","array","isFirst","width","flattenedHeadersLengthAtom","headerCellsRefsAtom","fill","headerCellsHeightsAtom","height","headerCellsHeightsHashAtom","headerCellsHeights","headerRowsHeightsAtom","arr","flattenedHeadersWithHeights","apply","lowHeadersAtom","lowHeaderslengthAtom","resizersRefsAtom","headerHeightAtom","stickyTopOffsetsAtom","resizerTopOffsetsAtom","flattenedHeadersLowCellsKeysAtom","stickyLeftOffsetsAtom","stickyRightOffsetsAtom","bordersFlattenedHeadersAtom","flattenedHeadersColumn","prevLowKey","lowIndex","intersectingColumnsAtom","leftNoVisibleItemsAtom","intersectingColumns","horizontalVirtualScroll","offset","rightNoVisibleItemsAtom"],"sources":["../../../../../src/components/Table/helpers.ts"],"sourcesContent":["import { useCreateAtom } from '@consta/uikit/__internal__/src/utils/state/useCreateAtom';\nimport { getElementSize } from '@consta/uikit/useResizeObserved';\nimport { AtomMut } from '@reatom/core';\nimport { useAtom } from '@reatom/npm-react';\nimport React, { createRef } from 'react';\n\nimport { useResizeObservedAtom } from '##/hooks/useResizeObservedAtom';\nimport { get, set } from '##/utils/object/get';\n\nimport { Header, Position, TableColumn } from './types';\n\nexport const columnDefaultMinWidth = 80;\nexport const separatorWidth = 8;\nexport const separatorLargeWidth = 24;\n\ntype TableColumnWidthKey<T> = TableColumn<T> & { key: string };\n\nconst reduceSum = (previousValue: number, currentValue: number) =>\n  previousValue + currentValue;\n\nconst getLastChildrenCount = <T>(columns: TableColumn<T>[]) => {\n  let count = 0;\n\n  const traverse = (cols: TableColumn<T>[]) => {\n    cols.forEach((item: TableColumn<T>) => {\n      if (item.columns?.length) {\n        traverse(item.columns);\n      } else {\n        count++;\n      }\n    });\n  };\n\n  traverse(columns);\n\n  return count;\n};\n\ntype MapColumnsItem = { columns?: MapColumnsItem[] };\n\nconst mapColumns = <T extends MapColumnsItem>(\n  columns: T[],\n  fn: (item: T, index: (string | number)[]) => void,\n  stopRef: { current: boolean } = { current: false },\n) => {\n  let index: (string | number)[] = [0];\n\n  while (\n    // @ts-ignore, первый элемент всегда number\n    index[0] <= columns.length - 1 &&\n    get(columns, index)\n  ) {\n    if (stopRef.current) {\n      break;\n    }\n    const currentIndex = [...index];\n    const item = get<T>(columns, currentIndex);\n\n    fn(item, currentIndex);\n\n    if (item.columns?.length) {\n      index = [...currentIndex, 'columns', 0];\n    }\n\n    if (!item.columns?.length) {\n      const nextIndex = [\n        ...currentIndex.slice(0, -1),\n        Number(currentIndex[currentIndex.length - 1]) + 1,\n      ];\n      if (get<MapColumnsItem>(columns, nextIndex)) {\n        index = nextIndex;\n      } else {\n        if (currentIndex.length === 1) {\n          index = [Number(currentIndex[0]) + 1];\n          continue;\n        }\n        let d = 1;\n\n        while (true) {\n          const upIndex = currentIndex.slice(0, -d * 2);\n          const nextIndex = [\n            ...upIndex.slice(0, -1),\n            Number(upIndex[upIndex.length - 1]) + 1,\n          ];\n          if (!upIndex.length) {\n            break;\n          }\n\n          if (get<MapColumnsItem>(columns, nextIndex)) {\n            index = nextIndex;\n            break;\n          }\n          // @ts-ignore, первый элемент всегда number\n          if (nextIndex[0] > columns.length - 1) {\n            index = nextIndex;\n            break;\n          }\n\n          d += 1;\n        }\n      }\n    }\n  }\n};\n\nconst pushByKey = <T>(\n  pushed: TableColumnWidthKey<T>,\n  inColumns: TableColumnWidthKey<T>[],\n) => {\n  let needAdd = true;\n  const stopRef = { current: false };\n\n  mapColumns<TableColumnWidthKey<T>>(\n    inColumns,\n    (item) => {\n      if (pushed.key === item.key) {\n        needAdd = false;\n        stopRef.current = true;\n      }\n    },\n    stopRef,\n  );\n\n  if (!needAdd) {\n    return;\n  }\n\n  const keySplited = pushed.key.split('-');\n  const parentKey = keySplited.slice(0, keySplited.length - 1).join('-');\n\n  if (!parentKey) {\n    inColumns.push(pushed);\n    return;\n  }\n\n  mapColumns<TableColumnWidthKey<T>>(inColumns, (item, index) => {\n    if (parentKey === item.key) {\n      const pushIndex = [...index, 'columns'];\n\n      set(inColumns, pushIndex, [\n        ...get<TableColumnWidthKey<T>[]>(inColumns, pushIndex),\n        pushed,\n      ]);\n    }\n  });\n};\n\nconst pushByIndex = <T>(\n  index: (string | number)[],\n  columns: TableColumn<T>[],\n  inColumns: TableColumnWidthKey<T>[],\n  pinned?: 'left' | 'right',\n) => {\n  let i = index.length - 1;\n  while (i >= 0) {\n    const currentI = i;\n    i--;\n\n    const tree = index.slice(0, index.length - currentI);\n\n    if (tree[tree.length - 1] === 'columns') {\n      continue;\n    }\n\n    pushByKey(\n      {\n        ...get<TableColumn<T>>(columns, tree),\n        columns: [],\n        pinned,\n        key: tree.filter((el) => el !== 'columns').join('-'),\n      },\n      inColumns,\n    );\n  }\n};\n\nconst transformPinnedColumns = <T>(columns: TableColumn<T>[]) => {\n  const pinnedLeftColumns: TableColumnWidthKey<T>[] = [];\n  const pinnedRightColumns: TableColumnWidthKey<T>[] = [];\n  const otherColumns: TableColumnWidthKey<T>[] = [];\n  const notPinnedColumns: TableColumnWidthKey<T>[] = [];\n\n  mapColumns<TableColumn<T>>(columns, (item, index) => {\n    if (!item.columns?.length && item.pinned === 'left') {\n      pushByIndex(index, columns, pinnedLeftColumns, 'left');\n      return;\n    }\n    if (!item.columns?.length && item.pinned === 'right') {\n      pushByIndex(index, columns, pinnedRightColumns, 'right');\n      return;\n    }\n    if (item.columns?.length || item.isSeparator || item.accessor) {\n      pushByIndex(index, columns, otherColumns);\n    }\n  });\n\n  mapColumns<TableColumnWidthKey<T>>(otherColumns, (item) => {\n    if (item.columns?.length || item.isSeparator || item.accessor) {\n      pushByKey(item, notPinnedColumns);\n    }\n  });\n\n  return [...pinnedLeftColumns, ...notPinnedColumns, ...pinnedRightColumns];\n};\n\nexport const transformColumns = <T>(\n  columns: TableColumn<T>[],\n  maxLevel: number,\n): Array<Header<T>>[] => {\n  const stack = [{ columns, index: 0 }];\n  const headersArr: Array<Header<T>>[] = [];\n  let col = 0;\n\n  while (stack.length) {\n    const level = stack.length - 1;\n    const node = stack[level];\n    const item = node.columns[node.index] as Header<T>;\n\n    if (item) {\n      if (!headersArr[level]) headersArr[level] = [];\n      const topHeaderGridIndex = stack[0].index;\n      const prevItem = headersArr[level][headersArr[level].length - 1];\n      const gridIndex = prevItem\n        ? prevItem.position.gridIndex + (prevItem.position.colSpan || 1)\n        : 0;\n      const mainId = level === 0 ? col++ : item.colId ?? 0;\n\n      const handledItem: Header<T> & {\n        position: Position;\n        colId?: number;\n        parentId?: number;\n      } = {\n        ...item,\n        position: {\n          topHeaderGridIndex,\n          gridIndex,\n          level,\n        },\n      };\n\n      if (level === 0) {\n        handledItem.colId = mainId;\n      }\n\n      if (!handledItem.columns?.length) {\n        handledItem.position.rowSpan = maxLevel - level;\n        headersArr[level].push(handledItem);\n        node.index++;\n      } else {\n        // TODO: Заменитть на функцию обхода по дереву, чтоб без рекурсии\n        handledItem.position.colSpan = getLastChildrenCount(\n          handledItem.columns,\n        );\n        headersArr[level].push(handledItem);\n        stack.push({\n          columns: handledItem.columns.map((el) => ({\n            ...el,\n            colId: col++,\n            parentId: mainId,\n          })),\n          index: 0,\n        });\n      }\n    } else {\n      stack.pop();\n      if (stack[stack.length - 1]) stack[stack.length - 1].index++;\n    }\n  }\n\n  return headersArr;\n};\n\nexport const getMaxLevel = <T>(columns: TableColumn<T>[]) => {\n  let count = 0;\n\n  const traverse = (cols: TableColumn<T>[], level = 1) => {\n    if (level > count) count = level;\n    cols.forEach((item: TableColumn<T>) => {\n      if (item.columns?.length) {\n        traverse(item.columns, level + 1);\n      }\n    });\n  };\n\n  traverse(columns);\n\n  return count;\n};\n\nconst getIsFirst = <T>(columns: Header<T>[], column: Header<T>): boolean => {\n  // TODO: нужно проверить с renderCell\n  const { colId, parentId, position, accessor } = column;\n  if (position.level === 0) {\n    return colId === 0;\n  }\n  const parent = columns.find((el) => el.colId === parentId);\n  return !!(\n    parent?.columns?.[0]?.accessor === accessor &&\n    (parent ? getIsFirst(columns, parent) : false)\n  );\n};\n\nexport type HeaderData<T> = {\n  headersAtom: AtomMut<Header<T>[][]>;\n  flattenedHeadersAtom: AtomMut<Header<T>[]>;\n  lowHeadersAtom: AtomMut<TableColumn<T>[]>;\n  headerRowsHeightsAtom: AtomMut<number[]>;\n  resizerTopOffsetsAtom: AtomMut<number[]>;\n  stickyTopOffsetsAtom: AtomMut<number[]>;\n  headerHeightAtom: AtomMut<number>;\n  resizersRefsAtom: AtomMut<React.RefObject<HTMLDivElement>[]>;\n  headerCellsRefsAtom: AtomMut<React.RefObject<HTMLDivElement>[]>;\n  stickyLeftOffsetsAtom: AtomMut<number[]>;\n  stickyRightOffsetsAtom: AtomMut<number[]>;\n  bordersFlattenedHeadersAtom: AtomMut<[boolean, boolean, boolean][]>;\n  intersectingColumnsAtom: AtomMut<boolean[]>;\n  rightNoVisibleItemsAtom: AtomMut<number>;\n  leftNoVisibleItemsAtom: AtomMut<number>;\n};\n\nconst getLowHeaders = <T>(columns: TableColumnWidthKey<T>[]) => {\n  const lowHeaders: TableColumnWidthKey<T>[] = [];\n  mapColumns<TableColumnWidthKey<T>>(columns, (item) => {\n    if (!item.columns?.length) {\n      lowHeaders.push(item);\n    }\n  });\n  return lowHeaders;\n};\n\nconst getStickyTopOffsets = <T>(\n  flattenedHeaders: Header<T>[],\n  headerRowsHeights: number[],\n) => {\n  const stickyTopOffsets: number[] = [];\n  for (let index = 0; index < flattenedHeaders.length; index++) {\n    const column = flattenedHeaders[index];\n    stickyTopOffsets.push(\n      headerRowsHeights.slice(0, column.position!.level).reduce(reduceSum, 0),\n    );\n  }\n  return stickyTopOffsets;\n};\n\nconst getResizerTopOffsets = <T>(\n  flattenedHeaders: Header<T>[],\n  lowHeaders: TableColumnWidthKey<T>[],\n  stickyTopOffsets: number[],\n) => {\n  const resizerTopOffsets: number[] = [];\n\n  for (let index = 0; index < lowHeaders.length; index++) {\n    const topOffsetIndex = flattenedHeaders.findIndex(\n      (item) => item.key === lowHeaders[index].key,\n    );\n\n    resizerTopOffsets.push(stickyTopOffsets[topOffsetIndex]);\n  }\n  return resizerTopOffsets;\n};\n\nconst getFlattenedHeadersLowCellsKeys = <T>(flattenedHeaders: Header<T>[]) => {\n  const lowCells = flattenedHeaders.map((flattenedHeaderCell) => {\n    const keys: string[] = [];\n    mapColumns<Header<T>>([flattenedHeaderCell], (item, index) => {\n      if (!item.columns?.length) {\n        keys.push(item.key);\n      }\n    });\n    return keys;\n  });\n\n  return lowCells;\n};\n\nconst getHeaderStickyLeftOffsets = <T>(\n  lowCellsKeys: string[][],\n  lowHeaders: TableColumnWidthKey<T>[],\n) => {\n  return lowCellsKeys.map((keys) =>\n    Math.min(\n      ...keys.map((key) => lowHeaders.findIndex((item) => item.key === key)),\n    ),\n  );\n};\n\nconst getHeaderStickyRightOffsets = <T>(\n  lowCellsKeys: string[][],\n  lowHeaders: TableColumnWidthKey<T>[],\n) => {\n  return lowCellsKeys.map((keys) =>\n    Math.max(\n      ...keys.map((key) => lowHeaders.findIndex((item) => item.key === key)),\n    ),\n  );\n};\n\nexport const useHeaderData = <T>(\n  columnsAtom: AtomMut<TableColumn<T>[]>,\n  virtualScrollAtom: AtomMut<boolean | undefined | [boolean, boolean]>,\n): HeaderData<T> => {\n  const horizontalVirtualScrollAtom = useCreateAtom((ctx) => {\n    const virtualScroll = ctx.spy(virtualScrollAtom) || false;\n    return Array.isArray(virtualScroll) ? virtualScroll[0] : virtualScroll;\n  });\n\n  const columnsWithPinnedAtom = useCreateAtom((ctx) =>\n    transformPinnedColumns(ctx.spy(columnsAtom)),\n  );\n\n  const headersAtom = useCreateAtom((ctx) => {\n    const columnsWithPinned = ctx.spy(columnsWithPinnedAtom);\n    return transformColumns(columnsWithPinned, getMaxLevel(columnsWithPinned));\n  });\n\n  const flattenedHeadersAtom = useCreateAtom((ctx) => {\n    const headers = ctx.spy(headersAtom);\n    return headers.flat().map((column, index, array) => ({\n      ...column,\n      position: {\n        ...column.position,\n        isFirst: getIsFirst(array, column),\n        width: column.width || 'auto',\n      },\n    })) as Header<T>[];\n  });\n\n  const flattenedHeadersLengthAtom = useCreateAtom(\n    (ctx) => ctx.spy(flattenedHeadersAtom).length,\n  );\n\n  const headerCellsRefsAtom = useCreateAtom((ctx) =>\n    new Array(ctx.spy(flattenedHeadersLengthAtom))\n      .fill(null)\n      .map(createRef<HTMLDivElement>),\n  );\n\n  const headerCellsHeightsAtom = useResizeObservedAtom(\n    useAtom(headerCellsRefsAtom)[0],\n    (el) => getElementSize(el).height,\n  );\n\n  const headerCellsHeightsHashAtom = useCreateAtom((ctx) => {\n    const headerCellsHeights = ctx.spy(headerCellsHeightsAtom);\n    return headerCellsHeights.join('-');\n  });\n\n  const headerRowsHeightsAtom = useCreateAtom((ctx) => {\n    const headers = ctx.spy(headersAtom);\n    const flattenedHeaders = ctx.spy(flattenedHeadersAtom);\n    ctx.spy(headerCellsHeightsHashAtom);\n    const headerCellsHeights = ctx.get(headerCellsHeightsAtom);\n\n    return headers.map((arr, index) => {\n      const flattenedHeadersWithHeights = flattenedHeaders.map((item, i) => ({\n        ...item,\n        position: { ...item.position, height: headerCellsHeights[i] },\n      }));\n      return Math.min.apply(\n        null,\n        flattenedHeadersWithHeights\n          .filter(\n            (col: TableColumn<T> & { position: Position }) =>\n              col.position.level === index,\n          )\n          .map((item, i) => item.position.height),\n      );\n    });\n  });\n\n  const lowHeadersAtom = useCreateAtom((ctx) =>\n    getLowHeaders(ctx.spy(columnsWithPinnedAtom)),\n  );\n\n  const lowHeaderslengthAtom = useCreateAtom(\n    (ctx) => ctx.spy(lowHeadersAtom).length,\n  );\n\n  // const resizersRefs = useRefs<HTMLDivElement>(lowHeaders.length);\n\n  const resizersRefsAtom = useCreateAtom((ctx) =>\n    new Array(ctx.spy(lowHeaderslengthAtom))\n      .fill(null)\n      .map(createRef<HTMLDivElement>),\n  );\n\n  const headerHeightAtom = useCreateAtom((ctx) =>\n    ctx.spy(headerRowsHeightsAtom).reduce(reduceSum),\n  );\n\n  const stickyTopOffsetsAtom = useCreateAtom((ctx) =>\n    getStickyTopOffsets(\n      ctx.spy(flattenedHeadersAtom),\n      ctx.spy(headerRowsHeightsAtom),\n    ),\n  );\n\n  const resizerTopOffsetsAtom = useCreateAtom((ctx) =>\n    getResizerTopOffsets(\n      ctx.spy(flattenedHeadersAtom),\n      ctx.spy(lowHeadersAtom),\n      ctx.spy(stickyTopOffsetsAtom),\n    ),\n  );\n\n  const flattenedHeadersLowCellsKeysAtom = useCreateAtom((ctx) =>\n    getFlattenedHeadersLowCellsKeys(ctx.spy(flattenedHeadersAtom)),\n  );\n\n  const stickyLeftOffsetsAtom = useCreateAtom((ctx) =>\n    getHeaderStickyLeftOffsets(\n      ctx.spy(flattenedHeadersLowCellsKeysAtom),\n      ctx.spy(lowHeadersAtom),\n    ),\n  );\n\n  const stickyRightOffsetsAtom = useCreateAtom((ctx) =>\n    getHeaderStickyRightOffsets(\n      ctx.spy(flattenedHeadersLowCellsKeysAtom),\n      ctx.spy(lowHeadersAtom),\n    ),\n  );\n\n  const bordersFlattenedHeadersAtom = useCreateAtom((ctx) => {\n    const flattenedHeaders = ctx.spy(flattenedHeadersAtom);\n    const lowHeaders = ctx.spy(lowHeadersAtom);\n    return flattenedHeaders.map((flattenedHeadersColumn, index) => {\n      let prevLowKey = '';\n      const stopRef = { current: false };\n      mapColumns(\n        [flattenedHeadersColumn],\n        (col) => {\n          if (!col.columns?.length) {\n            prevLowKey = col.key;\n            stopRef.current = true;\n          }\n        },\n        stopRef,\n      );\n\n      const lowIndex = lowHeaders.findIndex((col) => col.key === prevLowKey);\n\n      return [\n        !flattenedHeadersColumn.position.isFirst &&\n          !(\n            flattenedHeadersColumn.pinned !== 'left' &&\n            lowHeaders[lowIndex - 1]?.pinned === 'left'\n          ),\n        flattenedHeadersColumn.pinned === 'left' &&\n          flattenedHeaders[index + 1]?.pinned !== 'left',\n        flattenedHeadersColumn.position.level !== 0,\n      ];\n    }) as [boolean, boolean, boolean][];\n  });\n\n  const intersectingColumnsAtom = useCreateAtom<boolean[]>([]);\n\n  const leftNoVisibleItemsAtom = useCreateAtom((ctx) => {\n    const intersectingColumns = ctx.spy(intersectingColumnsAtom);\n    const horizontalVirtualScroll = ctx.spy(horizontalVirtualScrollAtom);\n\n    if (!horizontalVirtualScroll) {\n      return 0;\n    }\n\n    if (intersectingColumns.length === 0) {\n      return ctx.get(lowHeadersAtom).length;\n    }\n\n    let offset = 0;\n\n    while (intersectingColumns[offset] === false) {\n      offset++;\n    }\n\n    return offset;\n  });\n\n  const rightNoVisibleItemsAtom = useCreateAtom((ctx) => {\n    const intersectingColumns = ctx.spy(intersectingColumnsAtom);\n\n    const horizontalVirtualScroll = ctx.spy(horizontalVirtualScrollAtom);\n\n    if (!horizontalVirtualScroll) {\n      return 0;\n    }\n\n    let offset = intersectingColumns.length - 1;\n\n    while (intersectingColumns[offset] === false) {\n      offset--;\n    }\n\n    return intersectingColumns.length - offset - 1;\n  });\n\n  return {\n    headersAtom,\n    flattenedHeadersAtom,\n    lowHeadersAtom: lowHeadersAtom as unknown as AtomMut<TableColumn<T>[]>,\n    headerRowsHeightsAtom,\n    resizerTopOffsetsAtom,\n    headerHeightAtom,\n    resizersRefsAtom,\n    stickyTopOffsetsAtom,\n    stickyLeftOffsetsAtom,\n    stickyRightOffsetsAtom,\n    headerCellsRefsAtom,\n    bordersFlattenedHeadersAtom,\n    intersectingColumnsAtom,\n    rightNoVisibleItemsAtom,\n    leftNoVisibleItemsAtom,\n  };\n};\n"],"mappings":"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"}