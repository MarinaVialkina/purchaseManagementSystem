import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["children", "className", "headerHeightAtom", "spaceTopAtom", "sizesAtom", "topOffsetsAtom", "stickyTopOffsetsAtom", "headerZIndexAtom", "resizingAtom"],
    _excluded2 = ["children", "spaceTopAtom", "topOffsetsAtom", "headerHeightAtom", "lowHeadersAtom", "resizersRefsAtom", "header", "body", "resizable", "stickyTopOffsetsAtom", "stickyHeader", "headerZIndex", "intersectingColumnsAtom"];
import "./TableBody.css";
import { useCreateAtom } from '@consta/uikit/__internal__/src/utils/state/useCreateAtom';
import { usePropAtom } from '@consta/uikit/__internal__/src/utils/state/usePickAtom';
import { useSendToAtom } from '@consta/uikit/__internal__/src/utils/state/useSendToAtom';
import { cnMixScrollBar } from '@consta/uikit/MixScrollBar';
import { useForkRef } from '@consta/uikit/useForkRef';
import { getElementSize } from '@consta/uikit/useResizeObserved';
import { useAction, useAtom } from '@reatom/npm-react';
import React, { forwardRef, memo, useMemo, useRef } from 'react';
import { useResizeObservedAtom } from "../../../hooks/useResizeObservedAtom";
import { cn } from "../../../utils/bem";
import { columnDefaultMinWidth, separatorLargeWidth, separatorWidth } from "../helpers";
import { cnTableCell } from "../TableCell";
import { TableResizers } from "../TableResizers";
import { TableSeparatorTitles } from "../TableSeparatorTitles";
import { TableVirtualScrollSpaceTop } from "../TableVirtualScrollSpaceTop";
import { getGridTemplate, getStyleByArray, getStyleLeftOffsetsForStickyColumns, getStyleRightOffsetsForStickyColumns, printSize } from "./helpers";
import { useResizableColumns } from "./useResizableColumns";
export var cnTableBody = cn('TableBody');

var getRandomHash = function getRandomHash() {
  return Array.from(crypto.getRandomValues(new Uint8Array(16))).map(function (b) {
    return b.toString(16).padStart(2, '0');
  }).join('');
};

var Style = function Style(_ref) {
  var atom = _ref.atom,
      className = _ref.className;
  return React.createElement("style", null, ".".concat(className, " {"), " ", useAtom(atom)[0], " ", "}");
};

var Styles = memo(function (_ref2) {
  var atoms = _ref2.atoms,
      className = _ref2.className;
  return React.createElement(React.Fragment, null, atoms.map(function (atom, index) {
    return React.createElement(Style, {
      key: index,
      atom: atom,
      className: className
    });
  }));
}, function () {
  return true;
});
var TableBodyRoot = forwardRef(function (_ref3, ref) {
  var children = _ref3.children,
      className = _ref3.className,
      headerHeightAtom = _ref3.headerHeightAtom,
      spaceTopAtom = _ref3.spaceTopAtom,
      sizesAtom = _ref3.sizesAtom,
      topOffsetsAtom = _ref3.topOffsetsAtom,
      stickyTopOffsetsAtom = _ref3.stickyTopOffsetsAtom,
      headerZIndexAtom = _ref3.headerZIndexAtom,
      resizingAtom = _ref3.resizingAtom,
      otherProps = _objectWithoutProperties(_ref3, _excluded);

  var _useAtom = useAtom(cnTableBody({
    instance: getRandomHash()
  }).split(' ')[1]),
      _useAtom2 = _slicedToArray(_useAtom, 1),
      randomClass = _useAtom2[0];

  var bodyRef = useRef(null);
  var bodySizeAtom = useResizeObservedAtom(useMemo(function () {
    return [bodyRef];
  }, [bodyRef]), getElementSize);
  var bodyOffsetHeightSizeAtom = useResizeObservedAtom(useMemo(function () {
    return [bodyRef];
  }, [bodyRef]), function (el) {
    return (el === null || el === void 0 ? void 0 : el.scrollHeight) || 0;
  });
  var tableBodyHorizontalScrollHeightAtom = useResizeObservedAtom(useMemo(function () {
    return [bodyRef];
  }, [bodyRef]), function (el) {
    var clientHeight = (el === null || el === void 0 ? void 0 : el.clientHeight) || 0;
    var offsetHeight = (el === null || el === void 0 ? void 0 : el.offsetHeight) || 0;
    return offsetHeight - clientHeight;
  });
  var tableBodyHorizontalScrollHeightStyleAtom = useCreateAtom(function (ctx) {
    return "--table-body-horizontal-scroll-height: ".concat(ctx.spy(tableBodyHorizontalScrollHeightAtom)[0], "px;");
  });
  var tableBodyHeightAtom = useCreateAtom(function (ctx) {
    return "--table-body-height: ".concat(ctx.spy(bodySizeAtom)[0].height, "px;");
  });
  var bodyOffsetHeightAtom = useCreateAtom(function (ctx) {
    return "--table-body-offset-height: ".concat(ctx.spy(bodyOffsetHeightSizeAtom), "px;");
  });
  var tableBodyWidthAtom = useCreateAtom(function (ctx) {
    return "--table-body-width: ".concat(ctx.spy(bodySizeAtom)[0].width, "px;");
  });
  var tableHeaderHeightAtom = useCreateAtom(function (ctx) {
    return "--table-header-height: ".concat(ctx.spy(headerHeightAtom), "px;");
  });
  var tableBodySpaceTopAtom = useCreateAtom(function (ctx) {
    return "--table-body-space-top: ".concat(ctx.spy(spaceTopAtom), "px;");
  });
  var sizesLength = useCreateAtom(function (ctx) {
    return ctx.spy(sizesAtom).length;
  });
  var tableGrigColumnsLengthAtom = useCreateAtom(function (ctx) {
    return "--table-grid-columns-length: ".concat(ctx.spy(sizesLength), ";");
  });
  var tableGridTemplateColumnsAtom = useCreateAtom(function (ctx) {
    return "--table-grid-template-columns: ".concat(getGridTemplate(ctx.spy(sizesLength)), ";");
  });
  var tableColumnSizesAtom = useCreateAtom(function (ctx) {
    return getStyleByArray(ctx.spy(sizesAtom), '--table-column-size', printSize);
  });
  var tableColumnLeftOffsetsAtom = useCreateAtom(function (ctx) {
    return getStyleLeftOffsetsForStickyColumns(ctx.spy(sizesLength));
  });
  var tableColumnRightOffsetsAtom = useCreateAtom(function (ctx) {
    return getStyleRightOffsetsForStickyColumns(ctx.spy(sizesLength));
  });
  var tableResizerTopOffsetsAtom = useCreateAtom(function (ctx) {
    return getStyleByArray(ctx.spy(topOffsetsAtom), '--table-resizer-top-offset');
  });
  var tableResizerStickyTopOffsetsAtom = useCreateAtom(function (ctx) {
    return getStyleByArray(ctx.spy(stickyTopOffsetsAtom), '--table-column-sticky-top-offset');
  });
  var tableRowGridColumn = useCreateAtom(function (ctx) {
    return "--table-row-grid-column: span ".concat(ctx.spy(sizesLength));
  });
  var tableOverScrollDisplayAtom = useCreateAtom(function (ctx) {
    return ctx.spy(resizingAtom) ? '--table-over-scroll-display: block' : '';
  });
  var tableHeaderZIndexAtom = useCreateAtom(function (ctx) {
    return "--table-header-z-index: ".concat(ctx.spy(headerZIndexAtom), ";");
  });
  return React.createElement("div", Object.assign({}, otherProps, {
    className: cnTableBody(null, [cnMixScrollBar(), randomClass, className]),
    ref: useForkRef([ref, bodyRef])
  }), React.createElement(Styles, {
    className: randomClass,
    atoms: [tableBodyHorizontalScrollHeightStyleAtom, bodyOffsetHeightAtom, tableBodyHeightAtom, tableBodyWidthAtom, tableHeaderHeightAtom, tableBodySpaceTopAtom, tableGrigColumnsLengthAtom, tableGridTemplateColumnsAtom, tableRowGridColumn, tableOverScrollDisplayAtom, tableHeaderZIndexAtom, tableColumnSizesAtom, tableColumnLeftOffsetsAtom, tableColumnRightOffsetsAtom, tableResizerTopOffsetsAtom, tableResizerStickyTopOffsetsAtom]
  }), children);
});
export var TableBody = forwardRef(function (props, ref) {
  var children = props.children,
      spaceTopAtom = props.spaceTopAtom,
      topOffsetsAtom = props.topOffsetsAtom,
      headerHeightAtom = props.headerHeightAtom,
      lowHeadersAtom = props.lowHeadersAtom,
      resizersRefsAtom = props.resizersRefsAtom,
      header = props.header,
      body = props.body,
      resizable = props.resizable,
      stickyTopOffsetsAtom = props.stickyTopOffsetsAtom,
      stickyHeader = props.stickyHeader,
      headerZIndex = props.headerZIndex,
      intersectingColumnsAtom = props.intersectingColumnsAtom,
      otherProps = _objectWithoutProperties(props, _excluded2);

  var propsAtom = useSendToAtom(props);
  var headerZIndexAtom = usePropAtom(propsAtom, 'headerZIndex');
  var resizableAtom = usePropAtom(propsAtom, 'resizable');
  var bodyRef = useRef(null);
  var bodyElAtom = useCreateAtom(null);
  var setBodyEl = useAction(function (ctx, el) {
    return bodyElAtom(ctx, el);
  });

  var _useAtom3 = useAtom(function (ctx) {
    var lowHeaders = ctx.spy(lowHeadersAtom);
    var resizersRefs = ctx.spy(resizersRefsAtom);
    return lowHeaders.map(function (_ref4, index) {
      var isSeparator = _ref4.isSeparator,
          width = _ref4.width,
          minWidth = _ref4.minWidth,
          maxWidth = _ref4.maxWidth,
          title = _ref4.title;
      var currentSeparatorWidth = title ? separatorLargeWidth : separatorWidth;
      return isSeparator ? {
        ref: resizersRefs[index],
        maxWidth: currentSeparatorWidth,
        minWidth: currentSeparatorWidth,
        width: currentSeparatorWidth
      } : {
        ref: resizersRefs[index],
        minWidth: minWidth || columnDefaultMinWidth,
        maxWidth: maxWidth,
        width: width
      };
    });
  }),
      _useAtom4 = _slicedToArray(_useAtom3, 1),
      blocks = _useAtom4[0];

  var _useResizableColumns = useResizableColumns({
    resizable: resizable,
    container: bodyRef,
    blocks: blocks
  }),
      handlersAtom = _useResizableColumns.handlersAtom,
      sizesAtom = _useResizableColumns.sizesAtom,
      activeIndexAtom = _useResizableColumns.activeIndexAtom,
      resizingAtom = _useResizableColumns.resizingAtom;

  return React.createElement(TableBodyRoot, Object.assign({}, otherProps, {
    ref: useForkRef([ref, bodyRef, setBodyEl]),
    headerHeightAtom: headerHeightAtom,
    spaceTopAtom: spaceTopAtom,
    sizesAtom: sizesAtom,
    topOffsetsAtom: topOffsetsAtom,
    stickyTopOffsetsAtom: stickyTopOffsetsAtom,
    headerZIndexAtom: headerZIndexAtom,
    resizingAtom: resizingAtom
  }), React.createElement("div", {
    className: cnTableBody('OverScroll')
  }), header, React.createElement("div", {
    className: cnTableBody('Separator', {
      sticky: stickyHeader
    }, [cnTableCell()])
  }), React.createElement(TableSeparatorTitles, {
    lowHeadersAtom: lowHeadersAtom
  }), React.createElement(TableResizers, {
    bodyElAtom: bodyElAtom,
    lowHeadersAtom: lowHeadersAtom,
    resizersRefsAtom: resizersRefsAtom,
    handlersAtom: handlersAtom,
    resizableAtom: resizableAtom,
    activeIndexAtom: activeIndexAtom,
    intersectingColumnsAtom: intersectingColumnsAtom
  }), React.createElement(TableVirtualScrollSpaceTop, null), body);
});
//# sourceMappingURL=TableBody.js.map