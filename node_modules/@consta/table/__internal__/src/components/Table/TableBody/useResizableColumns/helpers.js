import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { trackPosition } from '@consta/uikit/__internal__/src/components/Slider/useSlider/helper';
import { useDebounce } from '@consta/uikit/useDebounce';
import { useResizeObserved } from '@consta/uikit/useResizeObserved';
import { useAction, useAtom } from '@reatom/npm-react';
import { useMemo } from 'react';

var minMax = function minMax(min, max, value) {
  if (typeof value === 'number') {
    if (max && min) {
      return Math.min(max, Math.max(min, value));
    }

    if (max) {
      return Math.min(max, value);
    }

    if (min) {
      return Math.max(min, value);
    }

    return value;
  }

  if (max === min) {
    return max;
  }

  return value;
};

export var sizesEq = function sizesEq(newSizes, sizes) {
  return newSizes.join('-') === sizes.join('-');
};

var getContainerWidth = function getContainerWidth(el) {
  return el ? Math.floor(el.clientWidth - (el.offsetWidth - el.getBoundingClientRect().width)) : undefined;
};

export var getRefsSizes = function getRefsSizes(blocks) {
  var gap = 0;
  return blocks.map(function (_ref) {
    var _ref$current;

    var ref = _ref.ref,
        maxWidth = _ref.maxWidth,
        minWidth = _ref.minWidth,
        width = _ref.width;
    var value = minMax(minWidth, maxWidth, (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.getBoundingClientRect().width) || (typeof width === 'number' ? minMax(minWidth, maxWidth, width) : width);

    if (typeof value === 'number') {
      var roundValue = Math.floor(value + gap);
      gap += value - roundValue;
      return roundValue;
    }

    return value;
  });
};

var getTargetBlockPosition = function getTargetBlockPosition(sizes, index) {
  return sizes.slice(0, index).map(function (el) {
    return typeof el === 'number' ? el : 0;
  }).reduce(function (val, a) {
    return (val !== null && val !== void 0 ? val : 0) + (a !== null && a !== void 0 ? a : 0);
  }, 0);
};

var getBlockMaxSizes = function getBlockMaxSizes(block) {
  return [(block === null || block === void 0 ? void 0 : block.minWidth) || 0, block === null || block === void 0 ? void 0 : block.maxWidth];
};

export var addResult = function addResult(result, sizes) {
  var newSizes = _toConsumableArray(sizes);

  for (var index = 0; index < result.length; index++) {
    newSizes[result[index][0]] = result[index][1];
  }

  return newSizes;
};
export var isSizesCalculate = function isSizesCalculate(sizes) {
  return !sizes.find(function (item) {
    return typeof item === 'string' || typeof item === 'undefined';
  });
};
export var getSizesSum = function getSizesSum(sizes) {
  return sizes.reduce(function (a, b) {
    return a + b;
  });
};

var getValidValues = function getValidValues(value, index, blocks, containerWidth, sizes, resizable) {
  var currentMinMax = getBlockMaxSizes(blocks[index]);
  var guardValue = minMax(currentMinMax[0], currentMinMax[1], value) || 0;
  var results = [[index, guardValue]];

  var newSizes = _toConsumableArray(sizes).map(function (size) {
    return typeof size === 'number' ? size : 0;
  });

  newSizes.splice(index, 1, guardValue);
  var newSizesSum = getSizesSum(newSizes);
  var nextIndex = blocks.length - 1;

  while (newSizes[nextIndex] && nextIndex > index && resizable === 'inside') {
    var gap = containerWidth - newSizesSum;
    var nextMinMax = getBlockMaxSizes(blocks[nextIndex]);
    var nextValue = minMax(nextMinMax[0], nextMinMax[1], newSizes[nextIndex] + gap) || 0;

    if (newSizes[nextIndex] + gap !== nextValue || nextValue === results[0][1]) {
      nextIndex -= 1;
      continue;
    }

    results.push([nextIndex, nextValue]);

    if (newSizesSum + gap === containerWidth) {
      break;
    }

    nextIndex -= 1;
  }

  var sizesSum = getSizesSum(addResult(results, newSizes));

  if (resizable === 'inside' && sizesSum !== containerWidth) {
    return [];
  }

  if (resizable === 'outside' && sizesSum < containerWidth) {
    newSizes.splice(index, 1, 0);
    return [[index, containerWidth - getSizesSum(newSizes)]];
  }

  return results;
};

export var getCalculatedSizes = function getCalculatedSizes(event, index, blocks, container, sizes, resizable) {
  var _trackPosition;

  var position = (_trackPosition = trackPosition(event)) === null || _trackPosition === void 0 ? void 0 : _trackPosition.x;

  if (position) {
    var _container$current, _container$current2;

    var containerWidth = getContainerWidth(container.current) || 0;
    var containerLeft = ((_container$current = container.current) === null || _container$current === void 0 ? void 0 : _container$current.getBoundingClientRect().left) || 0;
    var scrollLeft = ((_container$current2 = container.current) === null || _container$current2 === void 0 ? void 0 : _container$current2.scrollLeft) || 0;

    var _trackPosition2 = getTargetBlockPosition(sizes, index);

    var value = Math.floor(position + scrollLeft - containerLeft - _trackPosition2);
    return getValidValues(value, index, blocks, containerWidth, sizes, resizable);
  }

  return [];
};
export var useResizeContainer = function useResizeContainer(containerAtom, blocksAtom, resizableAtom, sizesAtom, set) {
  var _useAtom = useAtom(containerAtom),
      _useAtom2 = _slicedToArray(_useAtom, 1),
      containerRef = _useAtom2[0];

  return useResizeObserved(useMemo(function () {
    return [containerRef];
  }, [containerRef]), useDebounce(useAction(function (ctx, el) {
    var containerWidth = getContainerWidth(el);

    var newSizes = _toConsumableArray(ctx.get(sizesAtom));

    var resizable = ctx.get(resizableAtom);

    if (containerWidth && isSizesCalculate(newSizes)) {
      var blocks = ctx.get(blocksAtom);
      var sizesSum = getSizesSum(newSizes);
      var gap = containerWidth - sizesSum;

      if (resizable !== 'outside' && gap || resizable === 'outside' && gap > 0) {
        var index = blocks.length - 1;

        while (newSizes[index] && gap) {
          var blockMinMax = getBlockMaxSizes(blocks[index]);
          var size = newSizes[index];
          var newSize = minMax(blockMinMax[0], blockMinMax[1], newSizes[index] + gap) || 0;
          gap -= newSize - size;
          newSizes[index] = newSize;
          index -= 1;
        }
      }

      set(newSizes);
    }
  }), 10));
};
//# sourceMappingURL=helpers.js.map